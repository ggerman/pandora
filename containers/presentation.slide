Containers: docker
Balbuceos sobre una tecnología de moda.

* Links

.link https://www.docker.com/ Docker | https://www.docker.com/
.link https://www.vagrantup.com/ Vagrant | https://www.vagrantup.com/
.link https://www.chef.io/chef/ chef | https://www.chef.io/chef/
.link https://puppetlabs.com/ puppets | https://puppetlabs.com/
.link http://www.javiergarzas.com/2015/08/docker-vs-puppet-vs-vagrant-vs-chef.html docker vs puppet vs vagrant vs chef

* Licencias

En su mayoria tenemos opciones de elegir soluciones libres en esta teconología. Aunque como todo corre en un servidor terminaremos pagando para que nuestros containers corran en un infrestructura que es complicado saber sus licencias.

.image images/inspeccionar.jpg 323 800

* Licencias

.image images/docker.png 48 199 
Apache License | Version 2.0, January 2004 | https://www.apache.org/licenses/ [FREE]

.image images/vagrant.png 64 248
The MIT License [FREE]

.image images/virtualbox.png 68 358
GNU General Public License V2 [FREE]

* Licencias

.image images/puppet.png 53 157
.link https://puppetlabs.com/sites/default/files/Puppet%20Labs%20-%20FORM%20-%20Software%20License%20Agreement%20%28Puppet%20Enterprise%20-%20Clickwrap%29%203.7.14.pdf  Licencia | Privativa

.image images/chef.png 196 233
Apache License | Version 2.0, January 2004 | esta medio escondido pero esta así que [FREE]

.link https://github.com/chef/chef chef | source code

* boot2docker

_es_un_linuxito_ que sirve para correr containers Docker dentro de plataformas no Linux y también corre en Linux.

.link http://boot2docker.io/ http://boot2docker.io/

Es un desarrollo libre que nos permite correr la infraestructura de containers dentro de plataformas Windows / MacOs / Linux.

.image images/isolation.png 103 704

* Acerca de la charla

- Principalmente Docker

- ¿Porque vagrant?

- ¿Porque Chef?

- ¿Porque Puppet?

* Docker ¿Que es docker?

Docker nos permite empaquetar una aplicación con todas sus dependencias en un contenedor.

.image images/what_is_layered_filesystems_sm.png 190 200

Los contenedores Docker son un sistema de archivos completo donde podemos colocar nuestras aplicaciones con todas sus librerias. Aqui podemos instalar todo lo que necesitamos en un servidor y esto nos garantiza que estaremos ejecutando el mismo código con las mismas librerias independientemente del entorno.

* Docker - Isolation

"La buena práctica" - existe la idea de que cada containar por cuestiones de seguridad y menor promiscuidad debe estar corriendo solo una cosa y no mas que eso. A esto se le llama aislamiento y es algo que es muy valorado dentro de las comunidades de creadores de containers.

.image images/aislamiento-social.jpg

NOTA: es algo que esta bueno saberlo, pero a la hora de SHIP (enviar la aplicacion a un amigo que no es experto) no es tan útil ya que es mas sencillo hacer solo un container con todo adentro y listo.

* Docker - Usando

  Como discutimos en general a las tecnologias las debemos utilizar para servirnos de ellas.

En todas las charlas de Docker que e visto hay una fuerte tendencia a crear una infrestructura, con fines de empresa (seguridad, escalabilidad, etc ...)

Pero como programador también veo muchos beneficios que a veces no son tan parecidos a un deber ser de infraestructura empresarial. Y esto es que en tiempo de desarrollo meter toda una aplicación con sus dependencias en un solo container (app, database, etc...), es algo que puede ser útil y hacernos ganar tiempo.

  En este caso dejariamos las buenas practicas para el deploy 
  y nuestro equipo solo deberia conocer el comando.
  # docker import app.tar.gz

.image images/157594438.jpg

* Creando un container - Instalación

  Instalar docker

.link http://docs.docker.com/mac/started/ install | http://docs.docker.com/mac/started/

.image images/non-root.png

* Creando un container - search
  
  Buscar una imagen:
  # docker search volt

.image images/mongodb.png
  
* Creando un container - run / build

  En este caso run y build funcionan de la misma manera

Cuando corremos (run) o creamos una imagen (build) docker primero busca si no se encuentra en nuestro host local y si no esta allí, la descarga de docker hub. 

  Descarga los layers que le faltan para completar nuestra imagen.

.image images/busybox-pull.png  

* Creando un container - run / build -> ps -a

  Conocer los containers que estan corriendo en nuestro host.
  # docker ps -a

.image images/volt-ps-a.png

  Matar todos los containers corriendo en nuestro host
  # docker rm $(docker ps -a -q)

  Listar todas las imagenes alojadas en nuestro host
  # docker images 
  Borrar una imagen:
  # docker rmi -f 865a6d4ec0ed 

.image images/docker-img.png 

* Creando un container - hagamos correr volt con mongodb (1)

_Dockerfile_

.code volt/Dockerfile

.link http://voltframework.com/ VOLT | http://voltframework.com/

* Creando un container - hagamos correr volt con mongodb (2)

  # docker build -t voltframework .

.image images/volt-dockerfile-build.png

* Creando un container - RUN (1)

  # docker run -p 3000:3000 --name volt voltframework

.image images/volt-running-container.png

Aqui estamos corriendo una instancia de nuestra aplicación (container).
El parametro -d hace correr la instancia RUN como demonio.
  
  # docker run -d -p 3000:3000 --name volt voltframework

.image images/volt-running-daemon.png

* Creando un container - RUN (2)

.image images/volt-welcome-page.png

* Volt: conectando a la base de datos.

Volt tiene un archivo de configuración config/app.rb. Que a los fines de esta presentación voy a borrar y copiar uno con mi configuración para que funcione con una conección a otro container donde tendremos mongoDB.

/app.rb. Que a los fines de esta presentación voy a borrar y copiar uno con mi configuración para que funcione con una conección a otro container donde tendremos mongoDB.

.code volt/manualy.rb

* MongoDB: puesta en marcha de la base de datos.

  # docker run -d --name db --port 27017:27017 mongo

.image images/volt-mongodb-manualy.png

* MongoDB: puesta en marcha de la base de datos. (2)

  # docker ps -a
  CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS              PORTS                      NAMES
  91531052333f        mongo               "/entrypoint.sh mong   16 minutes ago      Up 16 minutes       0.0.0.0:27017->27017/tcp   db                  
  4602ce309ddc        voltframework       "bundle exec volt se   35 minutes ago      Up 35 minutes       0.0.0.0:3000->3000/tcp     volt
  # docker logs 4602ce309ddc

.image images/volt-docker-logs.png

  (divagando) >> Ejecutar un comando en un container corriendo.
  # docker exec -it 4602ce309ddc vim config/app.rb

.image images/volt-editing-configuration.png

* ¡ Listo ! Ya tenemos todo corriendo en containers

.image images/happy-docker.png

* DOCKER: Esta cosa tiene commits y layers

Cuando modificamos un container este es tan efimero como lo es nuestro entorno, para que los cambios persistan debemos hacer commits.

  ...

LAYERS: ¿a que nos referimos con esto?

Un container no es mas que un conjunto de layers agrupados.

 - Reciclaje de paquetes instalados
 - Reciclaje de tiempo de configuración

* docker-compose: haciendo las cosas más automáticas

Compose es una aplicación que nos permite automatizar toda la tarea de conexión entre nuestros containers.
Los links son generados por dentro del MAIN HOST de Docker si necesidad de publicar los puertos.

De esta manera lo unico que debemos mostrar es el puerto por el que queremos acceder a nuestra aplicación, dejando que docker orqueste las conecciones entre nuestros containers.

_docker-compose.yml_

.code volt/docker-compose.yml

* docker-compose: database link

Para crear la conexión entre los containers podemos, como hicimos manualmente publicar el puerto de la base de datos.

  ports:
    - "27017:27017"

O lo que corresponde, que es dejar que docker haga el link entre VOLT y Mongo, para esto debemos modificar la configuración de VOLT linkeando con el nuevo nombre.

.code volt/compose.rb

* docker-compose: UP

  # docker-compose up

* 2

Linea de comando:

  # docker build -t myname/tag .

* Docker images

Utilizando images obtenemos un listado de todas nuestros contenedores (no necesariamente corriendo en nuestro sistema). Si alguno de estos containers nos molesta o queremos desacernos de él lo podemos remover con rmi o rmi -f y a continuación su ID.

.image images/docker-images.png 166 937

Estas imagenes estan listas para correr.

* Docker Run

  docker run --name ruby-postgres -e POSTGRES_PASSWORD=asdasd123 -d postgres
